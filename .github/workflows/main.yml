name: Build, Test, and Deploy Bookstore App (Improved) .

on:
  push:
    branches:
      - test
      
  pull_request:
    branches:
      - test

env:
  JAVA_VERSION: '17'
  JAVA_DISTRIBUTION: 'temurin'
  APP_NAME: 'bookstore'
  DEPLOY_PORT: '8080'

jobs:
  # Add a cleanup job to run first
  cleanup:
    name: Cleanup Runner Environment
    runs-on: self-hosted
    
    steps:
      - name: Cleanup workspace
        run: |
          echo "Cleaning up workspace..."
          # Clean up any existing processes
          pkill -f maven || true
          pkill -f java || true
          
          # Clean up workspace
          rm -rf ${GITHUB_WORKSPACE}/* || true
          
          # Clean up docker containers if any
          docker container prune -f || true
          docker image prune -f || true
          
          echo "Cleanup completed"
        continue-on-error: true

  test:
    name: Run Tests & Code Coverage
    runs-on: self-hosted
    needs: cleanup
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          clean: true  # Force clean checkout
        
      - name: Set up JDK ${{ env.JAVA_VERSION }}
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: ${{ env.JAVA_DISTRIBUTION }}
          cache: maven
          
      - name: Make Maven wrapper executable
        run: |
          cd ${{ env.APP_NAME }}
          chmod +x ./mvnw
          
      - name: Verify Maven wrapper
        run: |
          cd ${{ env.APP_NAME }}
          ls -la ./mvnw
          ./mvnw --version
          
      - name: Run tests with coverage
        run: |
          cd ${{ env.APP_NAME }}
          ./mvnw clean test jacoco:report --batch-mode --no-transfer-progress
        timeout-minutes: 15  # Add timeout to prevent hanging
          
      - name: Generate test report
        if: always()
        run: |
          cd ${{ env.APP_NAME }}
          echo "=== Test Results ==="
          if [ -d "target/surefire-reports" ]; then
            find target/surefire-reports -name "*.xml" -exec grep -l "testcase" {} \; | wc -l | xargs echo "Test files found:"
            echo "Coverage report: target/site/jacoco/index.html"
          fi
          
      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results-${{ github.run_id }}  # Make artifact names unique
          path: |
            ${{ env.APP_NAME }}/target/surefire-reports/
            ${{ env.APP_NAME }}/target/site/jacoco/
          retention-days: 5

  build:
    name: Build Application
    runs-on: self-hosted
    needs: test
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          clean: true
        
      - name: Set up JDK ${{ env.JAVA_VERSION }}
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: ${{ env.JAVA_DISTRIBUTION }}
          cache: maven
          
      - name: Make Maven wrapper executable
        run: |
          cd ${{ env.APP_NAME }}
          chmod +x ./mvnw
          
      - name: Build application
        run: |
          cd ${{ env.APP_NAME }}
          ./mvnw clean package -DskipTests --batch-mode --no-transfer-progress
        timeout-minutes: 10
          
      - name: Verify JAR file
        run: |
          cd ${{ env.APP_NAME }}
          echo "=== Built JAR files ==="
          ls -la target/*.jar
          
      - name: Upload JAR artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.APP_NAME }}-jar-${{ github.run_id }}
          path: ${{ env.APP_NAME }}/target/*.jar
          retention-days: 5

  security-scan:
    name: Basic Security Scan
    runs-on: self-hosted
    needs: build
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          clean: true
        
      - name: Download JAR artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ env.APP_NAME }}-jar-${{ github.run_id }}
          path: ${{ env.APP_NAME }}/target/
          
      - name: Build Docker image for scanning
        run: |
          echo "Building Docker image for security scanning..."
          docker build -t ${{ env.APP_NAME }}:scan-${{ github.run_id }} .
          
      - name: Install Trivy
        run: |
          if ! command -v trivy &> /dev/null; then
            sudo apt-get update
            sudo apt-get install wget apt-transport-https gnupg lsb-release -y
            wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
            echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee -a /etc/apt/sources.list.d/trivy.list
            sudo apt-get update
            sudo apt-get install trivy -y
          fi
          trivy --version
          
      - name: Run Trivy filesystem scan
        run: |
          echo "=== Scanning source code ==="
          trivy fs \
            --scanners vuln \
            --severity HIGH,CRITICAL \
            --timeout 10m \
            --format table \
            --exit-code 0 \
            ${{ env.APP_NAME }}/
        timeout-minutes: 12
          
      - name: Run Trivy container scan
        run: |
          echo "=== Scanning Docker image ==="
          trivy image \
            --scanners vuln \
            --severity HIGH,CRITICAL \
            --timeout 20m \
            --format json \
            --output trivy-report-${{ github.run_id }}.json \
            ${{ env.APP_NAME }}:scan-${{ github.run_id }}
        timeout-minutes: 25
          
      - name: Upload Trivy scan results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: trivy-scan-results-${{ github.run_id }}
          path: trivy-report-${{ github.run_id }}.json
          retention-days: 5
          
      - name: Cleanup scan image
        if: always()
        run: |
          docker rmi ${{ env.APP_NAME }}:scan-${{ github.run_id }} || true
          
  deploy:
    name: Deploy Application
    runs-on: self-hosted
    needs: [test, build, security-scan]
    if: github.ref == 'refs/heads/main'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          clean: true
        
      - name: Download JAR artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ env.APP_NAME }}-jar-${{ github.run_id }}
          path: ${{ env.APP_NAME }}/target/
          
      - name: Verify downloaded artifacts
        run: |
          cd ${{ env.APP_NAME }}
          echo "=== Downloaded artifacts ==="
          ls -la target/
          
      - name: Check Docker and Docker Compose
        run: |
          echo "=== Docker version ==="
          docker --version
          echo "=== Docker Compose version ==="
          docker-compose --version || docker compose version
          
      - name: Stop existing containers
        run: |
          echo "Stopping existing containers..."
          docker-compose down --remove-orphans || true
        timeout-minutes: 5
          
      - name: Clean up database volume
        run: |
          echo "Cleaning up old database volume..."
          docker volume rm bookstore-ci-cd_db_data || true
          docker system prune -f || true
          
      - name: Build and deploy with Docker Compose
        run: |
          echo "Building and starting containers..."
          docker-compose up -d --build --force-recreate
        timeout-minutes: 10
          
      - name: Wait for application to start
        run: |
          echo "Waiting for application to start..."
          
          timeout=60
          counter=0
          
          while [ $counter -lt $timeout ]; do
            if docker-compose ps | grep -q "Up"; then
              echo "Containers are running, checking application health..."
              sleep 5
              
              if curl -f http://localhost:${{ env.DEPLOY_PORT }}/actuator/health 2>/dev/null || curl -f http://localhost:${{ env.DEPLOY_PORT }} 2>/dev/null; then
                echo "‚úÖ Application is responding!"
                break
              fi
            fi
            
            echo "Waiting... ($counter/$timeout)"
            sleep 2
            counter=$((counter + 2))
          done
          
          if [ $counter -ge $timeout ]; then
            echo "‚ö†Ô∏è Application may not be fully ready yet"
          fi
          
      - name: Final health check
        run: |
          echo "=== Final Health Check ==="
          
          if curl -f http://localhost:${{ env.DEPLOY_PORT }}/actuator/health 2>/dev/null; then
            echo "‚úÖ Health endpoint responding"
          elif curl -f http://localhost:${{ env.DEPLOY_PORT }} 2>/dev/null; then
            echo "‚úÖ Application endpoint responding"
          else
            echo "‚ö†Ô∏è Application may not be responding on port ${{ env.DEPLOY_PORT }}"
            echo "Container status:"
            docker-compose ps
          fi
          
          echo ""
          echo "üåê Application should be available at:"
          echo "   - http://localhost:${{ env.DEPLOY_PORT }}"
          
  # Final cleanup job
  final-cleanup:
    name: Final Cleanup
    runs-on: self-hosted
    needs: [deploy]
    if: always()
    
    steps:
      - name: Cleanup artifacts and containers
        run: |
          echo "Final cleanup..."
          # Clean up any remaining containers
          docker container prune -f || true
          docker image prune -f || true
          
          # Clean up workspace
          rm -rf ${GITHUB_WORKSPACE}/.git || true
          
          echo "Final cleanup completed"
        continue-on-error: true